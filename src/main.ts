import * as core from "@actions/core";
import * as github from "@actions/github";
import { context } from "@actions/github";
import { checkReleaseBranch } from "./utils/check-release-branch.js";
import { cleanupValidationChecks } from "./utils/cleanup-validation-checks.js";
import { createReleaseBranch } from "./utils/create-release-branch.js";
import { createValidationCheck } from "./utils/create-validation-check.js";
import { detectPublishableChanges } from "./utils/detect-publishable-changes.js";
import { generateReleaseNotesPreview } from "./utils/generate-release-notes-preview.js";
import { linkIssuesFromCommits } from "./utils/link-issues-from-commits.js";
import { updateReleaseBranch } from "./utils/update-release-branch.js";
import { updateStickyComment } from "./utils/update-sticky-comment.js";
import { validateBuilds } from "./utils/validate-builds.js";
import { validatePublishGitHubPackages } from "./utils/validate-publish-github-packages.js";
import { validateNPMPublish } from "./utils/validate-publish-npm.js";

interface Inputs {
	token: string;
	releaseBranch: string;
	targetBranch: string;
	packageManager: string;
	dryRun: boolean;
	anthropicApiKey?: string;
	claudeReviewPat?: string;
}

/**
 * Main action entrypoint for release workflow
 *
 * @remarks
 * This action implements a comprehensive release management workflow:
 *
 * **Phase 1: Release Branch Management**
 * - Detect publishable changes from changesets
 * - Check if release branch exists
 * - Create new release branch or update existing one
 *
 * **Phase 2: Release Validation** (on release branch)
 * - Link issues from commits
 * - Generate PR description with Claude
 * - Validate builds
 * - Validate NPM publish readiness
 * - Validate GitHub Packages publish readiness
 * - Create unified validation check
 * - Update sticky comment on PR
 * - Generate release notes preview
 *
 * **Phase 3: Release Publishing** (on merge to main)
 * - Detect release merge
 * - Publish packages to NPM and GitHub Packages
 * - Create git tags
 * - Create GitHub releases
 */
async function run(): Promise<void> {
	try {
		core.info("üöÄ Starting release workflow...");

		// Read inputs
		const inputs = {
			// GitHub App token (already generated by composite action or previous step)
			token: core.getInput("token", { required: true }),

			// Repository configuration
			releaseBranch: core.getInput("release-branch") || "changeset-release/main",
			targetBranch: core.getInput("target-branch") || "main",

			// Package manager (detected by setup step)
			packageManager: core.getInput("package-manager") || "pnpm",

			// Workflow mode
			dryRun: core.getBooleanInput("dry-run") || false,

			// Anthropic API key for Claude (optional, for PR description generation)
			anthropicApiKey: core.getInput("anthropic-api-key"),

			// GitHub PAT for operations requiring user context (optional)
			claudeReviewPat: core.getInput("claude-review-pat"),
		};

		core.debug(`Inputs: ${JSON.stringify(inputs, null, 2)}`);

		if (inputs.dryRun) {
			core.notice("üß™ Running in dry-run mode (preview only)");
		}

		// Determine which phase to run based on context
		const isReleaseBranch = context.ref === `refs/heads/${inputs.releaseBranch}`;
		const isMainBranch = context.ref === `refs/heads/${inputs.targetBranch}`;
		const commitMessage = context.payload.head_commit?.message || "";
		const isReleaseCommit = commitMessage.includes("chore: version packages");

		core.info(`Branch: ${context.ref}`);
		core.info(`Commit message: ${commitMessage}`);
		core.info(`Is release branch: ${isReleaseBranch}`);
		core.info(`Is main branch: ${isMainBranch}`);
		core.info(`Is release commit: ${isReleaseCommit}`);

		// Phase 3: Release Publishing (on merge to main with version commit)
		if (isMainBranch && isReleaseCommit) {
			core.info("\\nüì¶ Phase 3: Release Publishing");
			//await runPhase3Publishing(inputs);
			return;
		}

		// Phase 2: Release Validation (on release branch)
		if (isReleaseBranch) {
			core.info("\\n‚úÖ Phase 2: Release Validation");
			await runPhase2Validation(inputs);
			return;
		}

		// Phase 1: Release Branch Management (on main branch, non-release commit)
		if (isMainBranch && !isReleaseCommit) {
			core.info("\\nüåø Phase 1: Release Branch Management");
			await runPhase1BranchManagement(inputs);
			return;
		}

		// No action needed for other branches/scenarios
		core.info("‚è≠Ô∏è  No release action needed for this branch/commit");
	} catch (error) {
		core.setFailed(`Release workflow failed: ${error instanceof Error ? error.message : String(error)}`);
	}
}

/**
 * Phase 1: Release Branch Management
 *
 * @remarks
 * Runs on push to main (non-release commits):
 * 1. Detect publishable changes
 * 2. Check if release branch exists
 * 3. Create new branch or update existing one
 */
async function runPhase1BranchManagement(inputs: {
	token: string;
	releaseBranch: string;
	targetBranch: string;
	packageManager: string;
	dryRun: boolean;
	anthropicApiKey?: string;
	claudeReviewPat?: string;
}): Promise<void> {
	try {
		core.startGroup("Step 1: Detect Publishable Changes");

		// Import and run detect-publishable-changes

		const detectionResult = await detectPublishableChanges(inputs.packageManager, inputs.dryRun);

		core.setOutput("has_changes", detectionResult.hasChanges);
		core.setOutput("publishable_packages", JSON.stringify(detectionResult.packages));
		core.setOutput("detection_check_id", detectionResult.checkId);

		core.endGroup();

		// If no publishable changes, skip remaining steps
		if (!detectionResult.hasChanges) {
			core.notice("‚è≠Ô∏è  No publishable changes detected, skipping release branch management");
			return;
		}

		core.startGroup("Step 2: Check Release Branch");

		// Import and run check-release-branch

		const branchCheckResult = await checkReleaseBranch(inputs.releaseBranch, inputs.targetBranch, inputs.dryRun);

		core.setOutput("release_branch_exists", branchCheckResult.exists);
		core.setOutput("release_branch_has_open_pr", branchCheckResult.hasOpenPr);
		core.setOutput("release_pr_number", branchCheckResult.prNumber || "");
		core.setOutput("branch_check_id", branchCheckResult.checkId);

		core.endGroup();

		// Step 3: Create or update release branch
		if (!branchCheckResult.exists) {
			core.startGroup("Step 3: Create Release Branch");

			// Import and run create-release-branch
			const createResult = await createReleaseBranch();

			core.setOutput("release_branch_created", createResult.created);
			core.setOutput("release_pr_number", createResult.prNumber || "");
			core.setOutput("create_check_id", createResult.checkId);

			core.endGroup();
		} else {
			core.startGroup("Step 3: Update Release Branch");

			const updateResult = await updateReleaseBranch();

			core.setOutput("release_branch_updated", updateResult.success);
			core.setOutput("has_conflicts", updateResult.hadConflicts);
			core.setOutput("update_check_id", updateResult.checkId);

			core.endGroup();
		}

		core.notice("‚úÖ Phase 1 completed successfully");
	} catch (error) {
		core.setFailed(`Phase 1 failed: ${error instanceof Error ? error.message : String(error)}`);
		throw error;
	}
}

/**
 * Phase 2: Release Validation
 *
 * @remarks
 * Runs on push to release branch:
 * 1. Link issues from commits
 * 2. Generate PR description
 * 3. Validate builds
 * 4. Validate NPM publish
 * 5. Validate GitHub Packages publish
 * 6. Create validation check
 * 7. Update sticky comment
 * 8. Generate release notes preview
 */
async function runPhase2Validation(inputs: Inputs): Promise<void> {
	const octokit = github.getOctokit(inputs.token);

	const checkIds: number[] = [];
	const checkNames = [
		"Link Issues from Commits",
		"Generate PR Description",
		"Build Validation",
		"Publish Validation (NPM)",
		"Publish Validation (GitHub Packages)",
		"Release Notes Preview",
	];

	try {
		// Create all validation checks upfront for immediate visibility
		core.startGroup("Creating validation checks");

		const checkRuns = await Promise.all(
			checkNames.map((name) =>
				octokit.rest.checks.create({
					owner: context.repo.owner,
					repo: context.repo.repo,
					name: inputs.dryRun ? `üß™ ${name} (Dry Run)` : name,
					head_sha: context.sha,
					status: "queued",
				}),
			),
		);

		checkIds.push(...checkRuns.map((r) => r.data.id));
		core.info(`Created ${checkIds.length} validation checks`);

		core.endGroup();

		// Step 1: Link issues from commits
		core.startGroup("Step 1: Link Issues from Commits");

		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[0],
			status: "in_progress",
		});

		const issuesResult = await linkIssuesFromCommits();

		core.setOutput("linked_issues", JSON.stringify(issuesResult.linkedIssues));
		core.setOutput("issue_commits", JSON.stringify(issuesResult.commits));

		core.endGroup();

		// Step 2: Generate PR description
		core.startGroup("Step 2: Generate PR Description");

		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[1],
			status: "in_progress",
		});

		// Note: generate-pr-description is designed for github-script execution
		// and requires Anthropic SDK integration. For now, we skip this step
		// if no API key is provided, or implement it via github-script in the workflow.
		if (inputs.anthropicApiKey) {
			core.info("Anthropic API key provided, but generate-pr-description requires github-script integration");
			// TODO: Integrate via github-script action in workflow
		}

		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[1],
			status: "completed",
			conclusion: inputs.anthropicApiKey ? "neutral" : "skipped",
			output: {
				title: inputs.anthropicApiKey ? "Not Implemented" : "Skipped",
				summary: inputs.anthropicApiKey
					? "PR description generation requires github-script integration (not yet implemented)"
					: "Anthropic API key not provided",
			},
		});
		core.endGroup();

		// Step 3: Validate builds
		core.startGroup("Step 3: Validate Builds");

		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[2],
			status: "in_progress",
		});

		const buildResult = await validateBuilds();

		core.setOutput("builds_passed", buildResult.success);
		core.setOutput("build_results", JSON.stringify([]));

		core.endGroup();

		// Initialize result variables
		let npmResult: { success: boolean; results?: unknown[] } = { success: false };
		let ghResult: { success: boolean; results?: unknown[] } = { success: false };

		// Only continue with publish validation if builds passed
		if (buildResult.success) {
			// Step 4: Validate NPM publish
			core.startGroup("Step 4: Validate NPM Publish");

			await octokit.rest.checks.update({
				owner: context.repo.owner,
				repo: context.repo.repo,
				check_run_id: checkIds[3],
				status: "in_progress",
			});

			npmResult = await validateNPMPublish(inputs.packageManager, inputs.dryRun);

			core.setOutput("npm_publish_ready", npmResult.success);
			core.setOutput("npm_results", JSON.stringify(npmResult.results));

			core.endGroup();

			// Step 5: Validate GitHub Packages publish
			core.startGroup("Step 5: Validate GitHub Packages Publish");

			await octokit.rest.checks.update({
				owner: context.repo.owner,
				repo: context.repo.repo,
				check_run_id: checkIds[4],
				status: "in_progress",
			});

			ghResult = await validatePublishGitHubPackages(inputs.packageManager, inputs.dryRun);

			core.setOutput("github_packages_ready", ghResult.success);
			core.setOutput("github_packages_results", JSON.stringify([]));

			core.endGroup();
		} else {
			// Skip publish validation if builds failed
			core.warning("Builds failed, skipping publish validation");

			for (let i = 3; i <= 4; i++) {
				await octokit.rest.checks.update({
					owner: context.repo.owner,
					repo: context.repo.repo,
					check_run_id: checkIds[i],
					status: "completed",
					conclusion: "skipped",
					output: {
						title: "Skipped",
						summary: "Build validation failed",
					},
				});
			}
		}

		// Step 6: Generate release notes preview
		core.startGroup("Step 6: Generate Release Notes Preview");

		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[5],
			status: "in_progress",
		});

		await generateReleaseNotesPreview();

		core.endGroup();

		// Step 7: Create unified validation check
		core.startGroup("Step 7: Create Unified Validation Check");

		const validationResults = [
			{ name: checkNames[0], success: true, checkId: checkIds[0] },
			{ name: checkNames[1], success: true, checkId: checkIds[1] },
			{ name: checkNames[2], success: buildResult.success, checkId: checkIds[2] },
			{
				name: checkNames[3],
				success: buildResult.success && npmResult.success,
				checkId: checkIds[3],
			},
			{
				name: checkNames[4],
				success: buildResult.success && ghResult.success,
				checkId: checkIds[4],
			},
			{ name: checkNames[5], success: true, checkId: checkIds[5] },
		];

		await createValidationCheck(validationResults, inputs.dryRun);

		core.endGroup();

		// Step 8: Update sticky comment on PR
		core.startGroup("Step 8: Update Sticky Comment");

		try {
			// Find the PR for the release branch
			const { data: prs } = await octokit.rest.pulls.list({
				owner: context.repo.owner,
				repo: context.repo.repo,
				state: "open",
				head: `${context.repo.owner}:${inputs.releaseBranch}`,
				base: inputs.targetBranch,
			});

			if (prs.length > 0) {
				const pr = prs[0];
				core.info(`Found release PR #${pr.number}`);

				// Generate validation summary
				const allSuccess = validationResults.every((r) => r.success);
				const failedChecks = validationResults.filter((r) => !r.success);

				const commentBody = `<!-- sticky-comment-id: release-validation -->
## üì¶ Release Validation ${allSuccess ? "‚úÖ" : "‚ùå"}

${inputs.dryRun ? "> üß™ **DRY RUN MODE** - No actual publishing will occur\n\n" : ""}

### Validation Results

| Check | Status |
|-------|--------|
${validationResults.map((r) => `| ${r.name} | ${r.success ? "‚úÖ Passed" : "‚ùå Failed"} |`).join("\n")}

${
	failedChecks.length > 0
		? `### ‚ùå Failed Checks\n\n${failedChecks.map((c) => `- **${c.name}**`).join("\n")}\n\nPlease resolve the issues above before merging.`
		: "### ‚úÖ All Validations Passed\n\nThis PR is ready to merge!"
}

---

<sub>Updated at ${new Date().toISOString()}</sub>
`;

				await updateStickyComment(pr.number, commentBody, "release-validation");
				core.info("‚úÖ Updated sticky comment on PR");
			} else {
				core.warning("No open PR found for release branch - skipping sticky comment update");
			}
		} catch (stickyError) {
			core.warning(
				`Failed to update sticky comment: ${stickyError instanceof Error ? stickyError.message : String(stickyError)}`,
			);
			// Don't fail the entire workflow if sticky comment update fails
		}

		core.endGroup();

		core.notice("‚úÖ Phase 2 completed successfully");
	} catch (error) {
		// Cleanup incomplete checks on error
		core.error(`Phase 2 failed: ${error instanceof Error ? error.message : String(error)}`);

		if (checkIds.length > 0) {
			core.info("Cleaning up incomplete validation checks...");
			await cleanupValidationChecks(
				checkIds,
				error instanceof Error ? error.message : "Workflow failed",
				inputs.dryRun,
			);
		}

		core.setFailed(`Phase 2 failed: ${error instanceof Error ? error.message : String(error)}`);
		throw error;
	}
}

// Run the action
await run();
