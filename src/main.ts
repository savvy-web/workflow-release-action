import * as core from "@actions/core";
import * as exec from "@actions/exec";
import * as github from "@actions/github";
import { context } from "@actions/github";
import { checkReleaseBranch } from "./utils/check-release-branch.js";
import { cleanupValidationChecks } from "./utils/cleanup-validation-checks.js";
import { closeLinkedIssues } from "./utils/close-linked-issues.js";
import { createReleaseBranch } from "./utils/create-release-branch.js";
import { createValidationCheck } from "./utils/create-validation-check.js";
import { detectPublishableChanges } from "./utils/detect-publishable-changes.js";
import { generatePRDescriptionDirect } from "./utils/generate-pr-description.js";
import { generateReleaseNotesPreview } from "./utils/generate-release-notes-preview.js";
import { linkIssuesFromCommits } from "./utils/link-issues-from-commits.js";
import { PHASE, logger } from "./utils/logger.js";
import { summaryWriter } from "./utils/summary-writer.js";
import { updateReleaseBranch } from "./utils/update-release-branch.js";
import { updateStickyComment } from "./utils/update-sticky-comment.js";
import { validateBuilds } from "./utils/validate-builds.js";
import { validatePublish } from "./utils/validate-publish.js";

interface Inputs {
	token: string;
	releaseBranch: string;
	targetBranch: string;
	packageManager: string;
	dryRun: boolean;
	anthropicApiKey?: string;
	claudeReviewPat?: string;
}

/**
 * Main action entrypoint for release workflow
 *
 * @remarks
 * This action implements a comprehensive release management workflow:
 *
 * **Phase 1: Release Branch Management**
 * - Detect publishable changes from changesets
 * - Check if release branch exists
 * - Create new release branch or update existing one
 *
 * **Phase 2: Release Validation** (on release branch)
 * - Link issues from commits
 * - Generate PR description with Claude
 * - Validate builds
 * - Validate publishing (multi-registry: NPM, GitHub Packages, JSR, custom)
 * - Generate release notes preview
 * - Create unified validation check
 * - Update sticky comment on PR
 *
 * **Phase 3: Release Publishing** (on merge to main)
 * - Detect release merge
 * - Publish packages to NPM and GitHub Packages
 * - Create git tags
 * - Create GitHub releases
 */
async function run(): Promise<void> {
	try {
		logger.start();

		// Read inputs
		const inputs = {
			// GitHub App token (already generated by composite action or previous step)
			token: core.getInput("token", { required: true }),

			// Repository configuration
			releaseBranch: core.getInput("release-branch") || "changeset-release/main",
			targetBranch: core.getInput("target-branch") || "main",

			// Package manager (detected by setup step)
			packageManager: core.getInput("package-manager") || "pnpm",

			// Workflow mode
			dryRun: core.getBooleanInput("dry-run") || false,

			// Anthropic API key for Claude (optional, for PR description generation)
			anthropicApiKey: core.getInput("anthropic-api-key"),

			// GitHub PAT for operations requiring user context (optional)
			claudeReviewPat: core.getInput("claude-review-pat"),
		};

		core.debug(`Inputs: ${JSON.stringify(inputs, null, 2)}`);

		// Determine which phase to run based on context
		const isReleaseBranch = context.ref === `refs/heads/${inputs.releaseBranch}`;
		const isMainBranch = context.ref === `refs/heads/${inputs.targetBranch}`;
		const commitMessage = context.payload.head_commit?.message || "";
		const isReleaseCommit = commitMessage.includes("chore: version packages");

		// Detect PR merge event
		const isPullRequestEvent = context.eventName === "pull_request";
		const pullRequest = context.payload.pull_request;
		const isPRMerged = isPullRequestEvent && pullRequest?.merged === true;
		const isReleasePRMerged =
			isPRMerged && pullRequest?.head?.ref === inputs.releaseBranch && pullRequest?.base?.ref === inputs.targetBranch;

		// Log context info
		logger.context({
			branch: context.ref,
			commitMessage,
			isReleaseBranch,
			isMainBranch,
			isReleaseCommit,
			isPullRequestEvent,
			isPRMerged,
			isReleasePRMerged,
			dryRun: inputs.dryRun,
		});

		// Phase 3a: Close linked issues (on release PR merge)
		if (isReleasePRMerged) {
			logger.phase(3, PHASE.publish, "Close Linked Issues");
			await runCloseLinkedIssues(inputs, pullRequest.number);
			return;
		}

		// Phase 3: Release Publishing (on merge to main with version commit)
		if (isMainBranch && isReleaseCommit) {
			logger.phase(3, PHASE.publish, "Release Publishing");
			//await runPhase3Publishing(inputs);
			return;
		}

		// Phase 2: Release Validation (on release branch)
		if (isReleaseBranch) {
			logger.phase(2, PHASE.validation, "Release Validation");
			await runPhase2Validation(inputs);
			return;
		}

		// Phase 1: Release Branch Management (on main branch, non-release commit)
		if (isMainBranch && !isReleaseCommit) {
			logger.phase(1, PHASE.branch, "Release Branch Management");
			await runPhase1BranchManagement(inputs);
			return;
		}

		// No action needed for other branches/scenarios
		logger.noAction("not on main or release branch");
	} catch (error) {
		core.setFailed(`Release workflow failed: ${error instanceof Error ? error.message : String(error)}`);
	}
}

/**
 * Phase 1: Release Branch Management
 *
 * @remarks
 * Runs on push to main (non-release commits):
 * 1. Detect publishable changes
 * 2. Check if release branch exists
 * 3. Create new branch or update existing one
 */
async function runPhase1BranchManagement(inputs: {
	token: string;
	releaseBranch: string;
	targetBranch: string;
	packageManager: string;
	dryRun: boolean;
	anthropicApiKey?: string;
	claudeReviewPat?: string;
}): Promise<void> {
	try {
		logger.step(1, "Detect Publishable Changes");

		const detectionResult = await detectPublishableChanges(inputs.packageManager, inputs.dryRun);

		core.setOutput("has_changes", detectionResult.hasChanges);
		core.setOutput("publishable_packages", JSON.stringify(detectionResult.packages));
		core.setOutput("detection_check_id", detectionResult.checkId);

		logger.endStep();

		// If no publishable changes, skip remaining steps
		if (!detectionResult.hasChanges) {
			logger.skip("No publishable changes detected, skipping release branch management");
			return;
		}

		logger.step(2, "Check Release Branch");

		const branchCheckResult = await checkReleaseBranch(inputs.releaseBranch, inputs.targetBranch, inputs.dryRun);

		core.setOutput("release_branch_exists", branchCheckResult.exists);
		core.setOutput("release_branch_has_open_pr", branchCheckResult.hasOpenPr);
		core.setOutput("release_pr_number", branchCheckResult.prNumber || "");
		core.setOutput("branch_check_id", branchCheckResult.checkId);

		logger.endStep();

		// Step 3: Create or update release branch
		if (!branchCheckResult.exists) {
			logger.step(3, "Create Release Branch");

			const createResult = await createReleaseBranch();

			core.setOutput("release_branch_created", createResult.created);
			core.setOutput("release_pr_number", createResult.prNumber || "");
			core.setOutput("create_check_id", createResult.checkId);

			logger.endStep();
		} else {
			logger.step(3, "Update Release Branch");

			const updateResult = await updateReleaseBranch();

			core.setOutput("release_branch_updated", updateResult.success);
			core.setOutput("has_conflicts", updateResult.hadConflicts);
			core.setOutput("update_check_id", updateResult.checkId);

			logger.endStep();
		}

		logger.phaseComplete(1);
	} catch (error) {
		core.setFailed(`Phase 1 failed: ${error instanceof Error ? error.message : String(error)}`);
		throw error;
	}
}

/**
 * Phase 2: Release Validation
 *
 * @remarks
 * Runs on push to release branch:
 * 1. Link issues from commits
 * 2. Generate PR description
 * 3. Validate builds
 * 4. Validate NPM publish
 * 5. Validate GitHub Packages publish
 * 6. Create validation check
 * 7. Update sticky comment
 * 8. Generate release notes preview
 */
async function runPhase2Validation(inputs: Inputs): Promise<void> {
	const octokit = github.getOctokit(inputs.token);

	// Fetch full history for changeset comparisons
	// Changesets needs to find the merge base between the release branch and target branch,
	// which requires having enough commit history to find where they diverged.
	// A shallow clone with depth=1 won't have the common ancestor.
	core.startGroup("Fetching git history for changeset comparison");
	try {
		// First, unshallow the current branch if it's a shallow clone
		let isShallow = false;
		try {
			let shallowCheck = "";
			await exec.exec("git", ["rev-parse", "--is-shallow-repository"], {
				listeners: {
					stdout: (data: Buffer) => {
						shallowCheck += data.toString();
					},
				},
			});
			isShallow = shallowCheck.trim() === "true";
		} catch {
			// If the check fails, assume it's not shallow
		}

		if (isShallow) {
			core.info("Repository is shallow, fetching full history...");
			await exec.exec("git", ["fetch", "--unshallow", "origin"]);
			core.info("âœ“ Unshallowed repository");
		}

		// Fetch the target branch and create a local ref
		// Changesets needs a local branch ref, not just origin/main
		await exec.exec("git", ["fetch", "origin", `${inputs.targetBranch}:${inputs.targetBranch}`]);
		core.info(`âœ“ Fetched ${inputs.targetBranch} branch`);
	} catch (error) {
		core.warning(
			`Failed to fetch git history: ${error instanceof Error ? error.message : String(error)}. Changeset status may fail.`,
		);
	}
	core.endGroup();

	const checkIds: number[] = [];
	const checkNames = [
		"Link Issues from Commits",
		"Generate PR Description",
		"Build Validation",
		"Publish Validation",
		"Release Notes Preview",
	];

	try {
		// Create all validation checks upfront for immediate visibility
		logger.step(0, "Creating Validation Checks");

		const checkRuns = await Promise.all(
			checkNames.map((name) =>
				octokit.rest.checks.create({
					owner: context.repo.owner,
					repo: context.repo.repo,
					name: inputs.dryRun ? `ðŸ§ª ${name} (Dry Run)` : name,
					head_sha: context.sha,
					status: "queued",
				}),
			),
		);

		checkIds.push(...checkRuns.map((r) => r.data.id));
		logger.success(`Created ${checkIds.length} validation checks`);

		logger.endStep();

		// Step 1: Link issues from commits
		logger.step(1, "Link Issues from Commits");

		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[0],
			status: "in_progress",
		});

		const issuesResult = await linkIssuesFromCommits();

		core.setOutput("linked_issues", JSON.stringify(issuesResult.linkedIssues));
		core.setOutput("issue_commits", JSON.stringify(issuesResult.commits));

		logger.endStep();

		// Step 2: Generate PR description
		logger.step(2, "Generate PR Description");

		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[1],
			status: "in_progress",
		});

		// Find the PR for the release branch to get PR number
		const { data: prs } = await octokit.rest.pulls.list({
			owner: context.repo.owner,
			repo: context.repo.repo,
			state: "open",
			head: `${context.repo.owner}:${inputs.releaseBranch}`,
			base: inputs.targetBranch,
		});

		if (prs.length > 0 && inputs.anthropicApiKey) {
			const pr = prs[0];
			logger.info(`Found release PR #${pr.number}, generating description with Claude`);

			try {
				const descResult = await generatePRDescriptionDirect(
					inputs.token,
					issuesResult.linkedIssues,
					issuesResult.commits,
					pr.number,
					inputs.anthropicApiKey,
					inputs.dryRun,
				);

				core.setOutput("pr_description", descResult.description);
				logger.success(`Generated PR description (${descResult.description.length} characters)`);

				await octokit.rest.checks.update({
					owner: context.repo.owner,
					repo: context.repo.repo,
					check_run_id: checkIds[1],
					status: "completed",
					conclusion: "success",
					output: {
						title: "PR Description Generated",
						summary: `Generated ${descResult.description.length} character description with Claude`,
					},
				});
			} catch (descError) {
				logger.warn(
					`Failed to generate PR description: ${descError instanceof Error ? descError.message : String(descError)}`,
				);
				await octokit.rest.checks.update({
					owner: context.repo.owner,
					repo: context.repo.repo,
					check_run_id: checkIds[1],
					status: "completed",
					conclusion: "neutral",
					output: {
						title: "PR Description Generation Failed",
						summary: descError instanceof Error ? descError.message : String(descError),
					},
				});
			}
		} else if (!inputs.anthropicApiKey) {
			logger.info("Anthropic API key not provided, skipping PR description generation");
			await octokit.rest.checks.update({
				owner: context.repo.owner,
				repo: context.repo.repo,
				check_run_id: checkIds[1],
				status: "completed",
				conclusion: "skipped",
				output: {
					title: "Skipped",
					summary: "Anthropic API key not provided",
				},
			});
		} else {
			logger.warn("No open PR found for release branch, skipping PR description generation");
			await octokit.rest.checks.update({
				owner: context.repo.owner,
				repo: context.repo.repo,
				check_run_id: checkIds[1],
				status: "completed",
				conclusion: "skipped",
				output: {
					title: "Skipped",
					summary: "No open PR found for release branch",
				},
			});
		}
		logger.endStep();

		// Step 3: Validate builds
		logger.step(3, "Validate Builds");

		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[2],
			status: "in_progress",
		});

		const buildResult = await validateBuilds();

		core.setOutput("builds_passed", buildResult.success);
		core.setOutput("build_results", JSON.stringify([]));

		// Complete the placeholder check
		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[2],
			status: "completed",
			conclusion: buildResult.success ? "success" : "failure",
			output: {
				title: buildResult.success ? "Build Validation Passed" : "Build Validation Failed",
				summary: buildResult.success ? "All builds completed successfully" : buildResult.errors,
			},
		});

		logger.endStep();

		// Initialize publish validation result
		let publishResult: {
			success: boolean;
			npmReady: boolean;
			githubPackagesReady: boolean;
			totalTargets: number;
			readyTargets: number;
			summary: string;
			validations: unknown[];
		} = {
			success: false,
			npmReady: false,
			githubPackagesReady: false,
			totalTargets: 0,
			readyTargets: 0,
			summary: "",
			validations: [],
		};

		// Only continue with publish validation if builds passed
		if (buildResult.success) {
			// Step 4: Validate publishing (multi-registry)
			logger.step(4, "Validate Publishing");

			await octokit.rest.checks.update({
				owner: context.repo.owner,
				repo: context.repo.repo,
				check_run_id: checkIds[3],
				status: "in_progress",
			});

			publishResult = await validatePublish(inputs.packageManager, inputs.targetBranch, inputs.dryRun);

			// Set outputs for backwards compatibility
			core.setOutput("npm_publish_ready", publishResult.npmReady);
			core.setOutput("github_packages_ready", publishResult.githubPackagesReady);
			core.setOutput("publish_results", JSON.stringify(publishResult.validations));

			// Determine check conclusion
			const conclusion = publishResult.totalTargets === 0 ? "skipped" : publishResult.success ? "success" : "failure";
			const title =
				publishResult.totalTargets === 0
					? "No packages to validate"
					: publishResult.success
						? `All ${publishResult.readyTargets} target(s) ready to publish`
						: `${publishResult.readyTargets}/${publishResult.totalTargets} target(s) ready`;

			// Complete the check
			await octokit.rest.checks.update({
				owner: context.repo.owner,
				repo: context.repo.repo,
				check_run_id: checkIds[3],
				status: "completed",
				conclusion,
				output: {
					title,
					summary: publishResult.summary,
				},
			});

			logger.endStep();
		} else {
			// Skip publish validation if builds failed
			logger.warn("Builds failed, skipping publish validation");

			await octokit.rest.checks.update({
				owner: context.repo.owner,
				repo: context.repo.repo,
				check_run_id: checkIds[3],
				status: "completed",
				conclusion: "skipped",
				output: {
					title: "Skipped",
					summary: "Build validation failed",
				},
			});
		}

		// Step 5: Generate release notes preview
		logger.step(5, "Generate Release Notes Preview");

		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[4],
			status: "in_progress",
		});

		const releaseNotesResult = await generateReleaseNotesPreview();

		// Complete the placeholder check
		await octokit.rest.checks.update({
			owner: context.repo.owner,
			repo: context.repo.repo,
			check_run_id: checkIds[4],
			status: "completed",
			conclusion: "success",
			output: {
				title: "Release Notes Preview Generated",
				summary: `Generated release notes for ${releaseNotesResult.packages.length} package(s)`,
			},
		});

		logger.endStep();

		// Step 6: Create unified validation check
		logger.step(6, "Create Unified Validation Check");

		const validationResults = [
			{ name: checkNames[0], success: true, checkId: checkIds[0] },
			{ name: checkNames[1], success: true, checkId: checkIds[1] },
			{ name: checkNames[2], success: buildResult.success, checkId: checkIds[2] },
			{
				name: checkNames[3],
				success: buildResult.success && publishResult.success,
				checkId: checkIds[3],
			},
			{ name: checkNames[4], success: true, checkId: checkIds[4] },
		];

		await createValidationCheck(validationResults, inputs.dryRun);

		logger.endStep();

		// Step 7: Update sticky comment on PR
		logger.step(7, "Update Sticky Comment");

		try {
			// Find the PR for the release branch
			const { data: prs } = await octokit.rest.pulls.list({
				owner: context.repo.owner,
				repo: context.repo.repo,
				state: "open",
				head: `${context.repo.owner}:${inputs.releaseBranch}`,
				base: inputs.targetBranch,
			});

			if (prs.length > 0) {
				const pr = prs[0];
				logger.success(`Found release PR #${pr.number}`);

				// Generate validation summary
				const allSuccess = validationResults.every((r) => r.success);
				const failedChecks = validationResults.filter((r) => !r.success);

				// Build validation results table
				const validationTable = summaryWriter.table(
					["Check", "Status"],
					validationResults.map((r) => [r.name, r.success ? "âœ… Passed" : "âŒ Failed"]),
				);

				// Build failed checks section or success message
				const statusSection =
					failedChecks.length > 0
						? summaryWriter.build([
								{
									heading: "âŒ Failed Checks",
									level: 3,
									content: `${summaryWriter.list(failedChecks.map((c) => `**${c.name}**`))}\n\nPlease resolve the issues above before merging.`,
								},
							])
						: summaryWriter.build([
								{
									heading: "âœ… All Validations Passed",
									level: 3,
									content: "This PR is ready to merge!",
								},
							]);

				const commentBody = `<!-- sticky-comment-id: release-validation -->
## ðŸ“¦ Release Validation ${allSuccess ? "âœ…" : "âŒ"}

${inputs.dryRun ? "> ðŸ§ª **DRY RUN MODE** - No actual publishing will occur\n\n" : ""}
### Validation Results

${validationTable}

${statusSection}
---

<sub>Updated at ${new Date().toISOString()}</sub>
`;

				await updateStickyComment(pr.number, commentBody, "release-validation");
				logger.success("Updated sticky comment on PR");
			} else {
				logger.warn("No open PR found for release branch - skipping sticky comment update");
			}
		} catch (stickyError) {
			logger.warn(
				`Failed to update sticky comment: ${stickyError instanceof Error ? stickyError.message : String(stickyError)}`,
			);
			// Don't fail the entire workflow if sticky comment update fails
		}

		logger.endStep();

		logger.phaseComplete(2);
	} catch (error) {
		// Cleanup incomplete checks on error
		logger.error(`Phase 2 failed: ${error instanceof Error ? error.message : String(error)}`);

		if (checkIds.length > 0) {
			logger.info("Cleaning up incomplete validation checks...");
			await cleanupValidationChecks(
				checkIds,
				error instanceof Error ? error.message : "Workflow failed",
				inputs.dryRun,
			);
		}

		core.setFailed(`Phase 2 failed: ${error instanceof Error ? error.message : String(error)}`);
		throw error;
	}
}

/**
 * Close linked issues when release PR is merged
 *
 * @remarks
 * Runs on pull_request closed event when:
 * - The PR was merged (not just closed)
 * - The PR is from the release branch to the target branch
 *
 * Uses GitHub's GraphQL API to find issues linked to the PR via
 * "fixes #123" keywords and closes each one with a comment.
 */
async function runCloseLinkedIssues(inputs: { token: string; dryRun: boolean }, prNumber: number): Promise<void> {
	try {
		logger.step(1, "Close Linked Issues");

		const result = await closeLinkedIssues(inputs.token, prNumber, inputs.dryRun);

		core.setOutput("closed_issues_count", result.closedCount);
		core.setOutput("failed_issues_count", result.failedCount);
		core.setOutput("closed_issues", JSON.stringify(result.issues));

		if (result.closedCount > 0) {
			logger.success(`Closed ${result.closedCount} linked issue(s)`);
		} else {
			logger.info("No linked issues to close");
		}

		if (result.failedCount > 0) {
			logger.warn(`Failed to close ${result.failedCount} issue(s)`);
		}

		logger.endStep();
		logger.phaseComplete(3);
	} catch (error) {
		core.setFailed(`Failed to close linked issues: ${error instanceof Error ? error.message : String(error)}`);
		throw error;
	}
}

// Run the action
await run();
