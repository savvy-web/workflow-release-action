import * as core from "@actions/core";
import * as exec from "@actions/exec";
import { context, getOctokit } from "@actions/github";

/**
 * Create release branch result
 */
interface CreateReleaseBranchResult {
	/** Whether the branch was created */
	created: boolean;
	/** PR number if PR was created */
	prNumber: number | null;
	/** GitHub check run ID */
	checkId: number;
	/** Version summary */
	versionSummary: string;
}

/**
 * Executes a command with retry logic and exponential backoff
 *

 * @param exec - GitHub Actions exec module
 * @param command - Command to execute
 * @param args - Command arguments
 * @param options - Exec options
 * @param maxRetries - Maximum number of retries (default: 3)
 * @returns Promise that resolves when command succeeds
 */
async function execWithRetry(
	command: string,
	args: string[],
	options: exec.ExecOptions = {},
	maxRetries: number = 3,
): Promise<void> {
	const retryableErrors = ["ECONNRESET", "ETIMEDOUT", "ENOTFOUND", "EAI_AGAIN"];
	const baseDelay = 1000;
	const maxDelay = 10000;

	for (let attempt = 0; attempt <= maxRetries; attempt++) {
		try {
			await exec.exec(command, args, options);
			return;
		} catch (error) {
			const isLastAttempt = attempt === maxRetries;
			/* v8 ignore next -- @preserve - Defensive: handles non-Error throws (extremely rare) */
			const errorMessage = error instanceof Error ? error.message : String(error);
			const isRetryable = retryableErrors.some((err) => errorMessage.includes(err));

			if (isLastAttempt || !isRetryable) {
				throw error;
			}

			// Exponential backoff with jitter
			const delay = Math.min(baseDelay * 2 ** attempt + Math.random() * 1000, maxDelay);
			core.warning(`Attempt ${attempt + 1} failed: ${errorMessage}. Retrying in ${Math.round(delay)}ms...`);

			await new Promise((resolve) => setTimeout(resolve, delay));
		}
	}
}

/**
 * Creates the release branch and PR
 *

 * @param exec - GitHub Actions exec module


 * @param releaseBranch - Release branch name
 * @param targetBranch - Target branch for PR
 * @param packageManager - Package manager to use
 * @param versionCommand - Custom version command
 * @param prTitlePrefix - Prefix for PR title
 * @param dryRun - Whether this is a dry-run
 * @returns Create release branch result
 */
export async function createReleaseBranch(): Promise<CreateReleaseBranchResult> {
	// Read all inputs
	const token = core.getInput("token", { required: true });
	const releaseBranch = core.getInput("release-branch") || "changeset-release/main";
	const targetBranch = core.getInput("target-branch") || "main";
	const packageManager = core.getInput("package-manager") || "pnpm";
	const versionCommand = core.getInput("version-command") || "";
	const prTitlePrefix = core.getInput("pr-title-prefix") || "chore: release";
	const dryRun = core.getBooleanInput("dry-run") || false;

	const github = getOctokit(token);

	core.startGroup("Creating release branch");

	// Configure git
	await exec.exec("git", ["config", "user.name", "github-actions[bot]"]);
	await exec.exec("git", ["config", "user.email", "github-actions[bot]@users.noreply.github.com"]);

	// Create and checkout release branch from target branch HEAD
	core.info(`Creating branch '${releaseBranch}' from '${targetBranch}' HEAD`);
	if (!dryRun) {
		await exec.exec("git", ["checkout", "-b", releaseBranch, `origin/${targetBranch}`]);
	} else {
		core.info(`[DRY RUN] Would create branch: ${releaseBranch} from origin/${targetBranch}`);
	}

	// Run changeset version
	core.info("Running changeset version");
	const versionCmd =
		versionCommand || (packageManager === "pnpm" ? "pnpm" : packageManager === "yarn" ? "yarn" : "npm");
	const versionArgs =
		versionCommand === ""
			? packageManager === "pnpm"
				? ["ci:version"]
				: packageManager === "yarn"
					? ["ci:version"]
					: ["run", "ci:version"]
			: versionCommand.split(" ");

	if (!dryRun) {
		await execWithRetry(versionCmd, versionArgs);
	} else {
		core.info(`[DRY RUN] Would run: ${versionCmd} ${versionArgs.join(" ")}`);
	}

	// Check for changes
	let hasChanges = false;
	let changedFiles = "";

	if (!dryRun) {
		await exec.exec("git", ["status", "--porcelain"], {
			listeners: {
				stdout: (data: Buffer) => {
					changedFiles += data.toString();
				},
			},
		});
		hasChanges = changedFiles.trim().length > 0;
	} else {
		// In dry-run mode, assume changes exist
		hasChanges = true;
		core.info("[DRY RUN] Assuming changes exist for version bump");
	}

	if (!hasChanges) {
		core.info("No changes generated by changeset version. Cleaning up and exiting.");
		if (!dryRun) {
			await exec.exec("git", ["checkout", targetBranch]);
			await exec.exec("git", ["branch", "-D", releaseBranch]);
		}
		core.endGroup();

		// Create check run for no changes
		const { data: checkRun } = await github.rest.checks.create({
			owner: context.repo.owner,
			repo: context.repo.repo,
			name: dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch",
			head_sha: context.sha,
			status: "completed",
			conclusion: "neutral",
			output: {
				title: "No version changes generated",
				summary: "Changeset version command did not produce any changes. No release branch created.",
			},
		});

		// Write job summary
		await core.summary
			.addHeading(dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch", 2)
			.addRaw("No version changes generated")
			.addEOL()
			.addRaw("Changeset version command did not produce any changes. No release branch created.")
			.write();

		return {
			created: false,
			prNumber: null,
			checkId: checkRun.id,
			versionSummary: "No changes",
		};
	}

	// Generate version summary from changed files
	const versionSummary = changedFiles
		.split("\n")
		.filter((line) => line.includes("package.json") || line.includes("CHANGELOG.md"))
		.join("\n");

	core.info("Version changes:");
	core.info(versionSummary);

	// Commit changes
	const commitMessage = `${prTitlePrefix}\n\nVersion bump from changesets`;
	if (!dryRun) {
		await exec.exec("git", ["add", "."]);
		await exec.exec("git", ["commit", "-m", commitMessage]);
	} else {
		core.info(`[DRY RUN] Would commit with message: ${commitMessage}`);
	}

	// Push branch with retry
	core.info(`Pushing branch '${releaseBranch}' to origin`);
	if (!dryRun) {
		await execWithRetry("git", ["push", "-u", "origin", releaseBranch]);
	} else {
		core.info(`[DRY RUN] Would push branch: ${releaseBranch}`);
	}

	core.endGroup();

	// Create PR with retry
	core.startGroup("Creating pull request");

	let prNumber: number | null = null;
	let prUrl = "";

	const prTitle = `${prTitlePrefix}`;

	// Build PR body using core.summary methods
	const prBodyBuilder = core.summary
		.addHeading("Release PR", 2)
		.addEOL()
		.addRaw("This PR was automatically generated by the release workflow.")
		.addEOL()
		.addEOL()
		.addHeading("Version Changes", 3)
		.addEOL()
		.addCodeBlock(versionSummary, "text")
		.addEOL();

	if (dryRun) {
		prBodyBuilder.addEOL().addRaw("---").addEOL().addRaw("**Mode**: Dry Run (Preview Only)").addEOL();
	}

	prBodyBuilder
		.addEOL()
		.addRaw("---")
		.addEOL()
		.addRaw(
			`ðŸ¤– Generated with [GitHub Actions](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,
		);

	const prBody = prBodyBuilder.stringify();

	if (!dryRun) {
		try {
			const { data: pr } = await github.rest.pulls.create({
				owner: context.repo.owner,
				repo: context.repo.repo,
				title: prTitle,
				head: releaseBranch,
				base: targetBranch,
				body: prBody,
			});

			prNumber = pr.number;
			prUrl = pr.html_url;

			// Add labels
			await github.rest.issues.addLabels({
				owner: context.repo.owner,
				repo: context.repo.repo,
				issue_number: prNumber,
				labels: ["automated", "release"],
			});

			core.info(`âœ“ Created PR #${prNumber}: ${prUrl}`);
		} catch (error) {
			// Retry PR creation once after brief delay
			core.warning(`PR creation failed, retrying: ${error instanceof Error ? error.message : String(error)}`);
			await new Promise((resolve) => setTimeout(resolve, 2000));

			const { data: pr } = await github.rest.pulls.create({
				owner: context.repo.owner,
				repo: context.repo.repo,
				title: prTitle,
				head: releaseBranch,
				base: targetBranch,
				body: prBody,
			});

			prNumber = pr.number;
			prUrl = pr.html_url;

			await github.rest.issues.addLabels({
				owner: context.repo.owner,
				repo: context.repo.repo,
				issue_number: prNumber,
				labels: ["automated", "release"],
			});

			core.info(`âœ“ Created PR #${prNumber}: ${prUrl}`);
		}
	} else {
		core.info(`[DRY RUN] Would create PR with title: ${prTitle}`);
		core.info(`[DRY RUN] PR body:\n${prBody}`);
	}

	core.endGroup();

	// Build check details using core.summary methods
	const checkSummaryBuilder = core.summary
		.addHeading("Release Branch Created", 2)
		.addEOL()
		.addTable([
			[
				{ data: "Property", header: true },
				{ data: "Value", header: true },
			],
			["Branch", `\`${releaseBranch}\``],
			["Target", `\`${targetBranch}\``],
			["PR", prNumber ? `[#${prNumber}](${prUrl})` : "_N/A (dry run)_"],
		])
		.addEOL()
		.addHeading("Version Changes", 3)
		.addEOL()
		.addCodeBlock(versionSummary, "text");

	if (dryRun) {
		checkSummaryBuilder.addEOL().addRaw("---").addEOL().addRaw("**Mode**: Dry Run (Preview Only)");
	}

	const checkDetails = checkSummaryBuilder.stringify();

	const { data: checkRun } = await github.rest.checks.create({
		owner: context.repo.owner,
		repo: context.repo.repo,
		name: dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch",
		head_sha: context.sha,
		status: "completed",
		conclusion: "success",
		output: {
			title: prNumber ? `Created release PR #${prNumber}` : "Release branch created (dry run)",
			summary: checkDetails,
		},
	});

	// Write job summary
	await core.summary
		.addHeading(dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch", 2)
		.addRaw(prNumber ? `Created release PR #${prNumber}` : "Release branch created (dry run)")
		.addEOL()
		.addHeading("Release Branch Created", 3)
		.addTable([
			[
				{ data: "Property", header: true },
				{ data: "Value", header: true },
			],
			["Branch", `\`${releaseBranch}\``],
			["Target", `\`${targetBranch}\``],
			["PR", prNumber ? `#${prNumber}` : "_N/A (dry run)_"],
		])
		.addHeading("Version Changes", 3)
		.addCodeBlock(versionSummary, "text")
		.write();

	return {
		created: true,
		prNumber,
		checkId: checkRun.id,
		versionSummary,
	};
}
