import { endGroup, getBooleanInput, getInput, getState, info, startGroup, warning } from "@actions/core";
import type { ExecOptions } from "@actions/exec";
import { exec } from "@actions/exec";
import { context, getOctokit } from "@actions/github";
import { createApiCommit } from "./create-api-commit.js";
import { getLinkedIssuesFromCommits } from "./link-issues-from-commits.js";
import { summaryWriter } from "./summary-writer.js";

/**
 * Create release branch result
 */
interface CreateReleaseBranchResult {
	/** Whether the branch was created */
	created: boolean;
	/** PR number if PR was created */
	prNumber: number | null;
	/** GitHub check run ID */
	checkId: number;
	/** Version summary */
	versionSummary: string;
}

/**
 * Executes a command with retry logic and exponential backoff
 *

 * @param exec - GitHub Actions exec module
 * @param command - Command to execute
 * @param args - Command arguments
 * @param options - Exec options
 * @param maxRetries - Maximum number of retries (default: 3)
 * @returns Promise that resolves when command succeeds
 */
async function execWithRetry(
	command: string,
	args: string[],
	options: ExecOptions = {},
	maxRetries: number = 3,
): Promise<void> {
	const retryableErrors = ["ECONNRESET", "ETIMEDOUT", "ENOTFOUND", "EAI_AGAIN"];
	const baseDelay = 1000;
	const maxDelay = 10000;

	for (let attempt = 0; attempt <= maxRetries; attempt++) {
		try {
			await exec(command, args, options);
			return;
		} catch (err) {
			const isLastAttempt = attempt === maxRetries;
			/* v8 ignore next -- @preserve - Defensive: handles non-Error throws (extremely rare) */
			const errorMessage = err instanceof Error ? err.message : String(err);
			const isRetryable = retryableErrors.some((errType) => errorMessage.includes(errType));

			if (isLastAttempt || !isRetryable) {
				throw err;
			}

			// Exponential backoff with jitter
			const delay = Math.min(baseDelay * 2 ** attempt + Math.random() * 1000, maxDelay);
			warning(`Attempt ${attempt + 1} failed: ${errorMessage}. Retrying in ${Math.round(delay)}ms...`);

			await new Promise((resolve) => setTimeout(resolve, delay));
		}
	}
}

/**
 * Creates the release branch and PR
 *

 * @param exec - GitHub Actions exec module


 * @param releaseBranch - Release branch name
 * @param targetBranch - Target branch for PR
 * @param packageManager - Package manager to use
 * @param versionCommand - Custom version command
 * @param prTitlePrefix - Prefix for PR title
 * @param dryRun - Whether this is a dry-run
 * @returns Create release branch result
 */
export async function createReleaseBranch(): Promise<CreateReleaseBranchResult> {
	// Read all inputs
	const token = getState("token");
	if (!token) {
		throw new Error("No token available from state - ensure pre.ts ran successfully");
	}
	const releaseBranch = getInput("release-branch") || "changeset-release/main";
	const targetBranch = getInput("target-branch") || "main";
	const packageManager = getState("packageManager") || "pnpm";
	const versionCommand = getInput("version-command") || "";
	const prTitlePrefix = getInput("pr-title-prefix") || "chore: release";
	const dryRun = getBooleanInput("dry-run") || false;

	const github = getOctokit(token);

	startGroup("Creating release branch");

	// Create and checkout release branch from target branch HEAD
	info(`Creating branch '${releaseBranch}' from '${targetBranch}' HEAD`);
	if (!dryRun) {
		await exec("git", ["checkout", "-b", releaseBranch, `origin/${targetBranch}`]);
	} else {
		info(`[DRY RUN] Would create branch: ${releaseBranch} from origin/${targetBranch}`);
	}

	// Run changeset version
	info("Running changeset version");
	const versionCmd =
		versionCommand ||
		(packageManager === "pnpm"
			? "pnpm"
			: packageManager === "yarn"
				? "yarn"
				: packageManager === "bun"
					? "bun"
					: "npm");
	const versionArgs =
		versionCommand === ""
			? packageManager === "pnpm"
				? ["ci:version"]
				: packageManager === "yarn"
					? ["ci:version"]
					: packageManager === "bun"
						? ["run", "ci:version"]
						: ["run", "ci:version"]
			: versionCommand.split(" ");

	if (!dryRun) {
		await execWithRetry(versionCmd, versionArgs);
	} else {
		info(`[DRY RUN] Would run: ${versionCmd} ${versionArgs.join(" ")}`);
	}

	// Check for changes
	let hasChanges = false;
	let changedFiles = "";

	if (!dryRun) {
		await exec("git", ["status", "--porcelain"], {
			listeners: {
				stdout: (data: Buffer) => {
					changedFiles += data.toString();
				},
			},
		});
		hasChanges = changedFiles.trim().length > 0;
	} else {
		// In dry-run mode, assume changes exist
		hasChanges = true;
		info("[DRY RUN] Assuming changes exist for version bump");
	}

	if (!hasChanges) {
		info("No changes generated by changeset version. Cleaning up and exiting.");
		if (!dryRun) {
			await exec("git", ["checkout", targetBranch]);
			await exec("git", ["branch", "-D", releaseBranch]);
		}
		endGroup();

		// Create check run for no changes
		const { data: checkRun } = await github.rest.checks.create({
			owner: context.repo.owner,
			repo: context.repo.repo,
			name: dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch",
			head_sha: context.sha,
			status: "completed",
			conclusion: "neutral",
			output: {
				title: "No version changes generated",
				summary: "Changeset version command did not produce any changes. No release branch created.",
			},
		});

		// Write job summary using summaryWriter (markdown, not HTML)
		const noChangesTitle = dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch";
		const noChangesSummary = summaryWriter.build([
			{ heading: noChangesTitle, content: "No version changes generated" },
			{ content: "Changeset version command did not produce any changes. No release branch created." },
		]);
		await summaryWriter.write(noChangesSummary);

		return {
			created: false,
			prNumber: null,
			checkId: checkRun.id,
			versionSummary: "No changes",
		};
	}

	// Generate version summary from changed files
	const versionSummary = changedFiles
		.split("\n")
		.filter((line) => line.includes("package.json") || line.includes("CHANGELOG.md"))
		.join("\n");

	info("Version changes:");
	info(versionSummary);

	// Get the current local commit SHA to use as parent for the API commit
	let parentSha = "";
	if (!dryRun) {
		await exec("git", ["rev-parse", "HEAD"], {
			listeners: {
				stdout: (data: Buffer) => {
					parentSha += data.toString().trim();
				},
			},
		});
		info(`Current HEAD: ${parentSha}`);
	}

	// Create commit via GitHub API (automatically signed and attributed to GitHub App)
	const commitMessage = `${prTitlePrefix}\n\nVersion bump from changesets`;
	let finalCommitSha = "";
	if (!dryRun) {
		info("Creating verified commit via GitHub API...");
		const commitResult = await createApiCommit(token, releaseBranch, commitMessage, {
			parentCommitSha: parentSha,
		});
		if (!commitResult.created) {
			warning("No changes to commit via API");
		} else {
			info(`âœ“ Created verified commit: ${commitResult.sha}`);
			finalCommitSha = commitResult.sha;
		}
	} else {
		info(`[DRY RUN] Would commit with message: ${commitMessage}`);
	}

	// Get repository node ID (needed for both branch linking and PR creation)
	let repoNodeId = "";
	if (!dryRun) {
		info("Fetching repository node ID...");
		const { data: repo } = await github.rest.repos.get({
			owner: context.repo.owner,
			repo: context.repo.repo,
		});
		repoNodeId = repo.node_id;
		info(`Repository node ID: ${repoNodeId}`);
	}

	// Link branch to issues from commits (AFTER creating the final commit)
	if (!dryRun && finalCommitSha) {
		startGroup("Linking branch to issues");
		try {
			info(`Searching for linked issues from commits on branch: ${targetBranch}`);
			const { linkedIssues, commits } = await getLinkedIssuesFromCommits(github, targetBranch);
			info(`Found ${commits.length} commit(s) to analyze`);

			if (linkedIssues.length > 0) {
				info(`Found ${linkedIssues.length} issue(s) to link to branch:`);
				for (const issue of linkedIssues) {
					info(`  - Issue #${issue.number}: ${issue.title} (${issue.node_id})`);
				}

				// Link the branch to each issue using the final commit SHA
				info(`Linking branch '${releaseBranch}' at commit ${finalCommitSha} to issues...`);
				for (const issue of linkedIssues) {
					try {
						info(`  Linking to issue #${issue.number}...`);
						await github.graphql(
							`
							mutation ($issueId: ID!, $name: String!, $oid: GitObjectID!, $repositoryId: ID!) {
								createLinkedBranch(input: {
									issueId: $issueId
									name: $name
									oid: $oid
									repositoryId: $repositoryId
								}) {
									linkedBranch {
										id
									}
								}
							}
							`,
							{
								issueId: issue.node_id,
								name: releaseBranch,
								oid: finalCommitSha,
								repositoryId: repoNodeId,
							},
						);
						info(`  âœ“ Linked branch to issue #${issue.number}`);
					} catch (error) {
						warning(
							`  Failed to link issue #${issue.number}: ${error instanceof Error ? error.message : String(error)}`,
						);
					}
				}

				info(`âœ“ Successfully linked branch to ${linkedIssues.length} issue(s)`);
			} else {
				info("No issues found to link to branch");
				info("This could mean:");
				info("  - No commits reference issues with 'Closes #N', 'Fixes #N', etc.");
				info("  - No merged PRs on this branch had linked issues");
			}
		} catch (error) {
			warning(`Failed to link branch to issues: ${error instanceof Error ? error.message : String(error)}`);
		}
		endGroup();
	} else if (!dryRun && !finalCommitSha) {
		info("No final commit SHA available, skipping branch linking");
	} else {
		info("[DRY RUN] Would link branch to issues from commits");
	}

	endGroup();

	// Create PR with retry
	startGroup("Creating pull request");

	let prNumber: number | null = null;
	let prUrl = "";

	const prTitle = `${prTitlePrefix}`;

	// Build PR body using summaryWriter (markdown, not HTML)
	const prBodySections: Array<{ heading?: string; level?: 2 | 3; content: string }> = [
		{ heading: "Release PR", content: "This PR was automatically generated by the release workflow." },
	];

	if (versionSummary) {
		prBodySections.push({
			heading: "Version Changes",
			level: 3,
			content: summaryWriter.codeBlock(versionSummary, "text"),
		});
	}

	const prBody = summaryWriter.build(prBodySections);

	if (!dryRun) {
		try {
			info(`Creating PR via GraphQL API...`);
			info(`  Repository: ${repoNodeId}`);
			info(`  Base: ${targetBranch}`);
			info(`  Head: ${releaseBranch}`);
			info(`  Title: ${prTitle}`);

			// Create PR via GraphQL (preserves branch-issue links)
			const prResult = (await github.graphql(
				`
				mutation ($repositoryId: ID!, $baseRefName: String!, $headRefName: String!, $title: String!, $body: String!) {
					createPullRequest(input: {
						repositoryId: $repositoryId
						baseRefName: $baseRefName
						headRefName: $headRefName
						title: $title
						body: $body
					}) {
						pullRequest {
							number
							url
							id
						}
					}
				}
				`,
				{
					repositoryId: repoNodeId,
					baseRefName: targetBranch,
					headRefName: releaseBranch,
					title: prTitle,
					body: prBody,
				},
			)) as { createPullRequest: { pullRequest: { number: number; url: string; id: string } } };

			prNumber = prResult.createPullRequest.pullRequest.number;
			prUrl = prResult.createPullRequest.pullRequest.url;
			info(`âœ“ PR created with GraphQL: #${prNumber} (${prResult.createPullRequest.pullRequest.id})`);

			// Add labels
			info(`Adding labels to PR #${prNumber}...`);
			await github.rest.issues.addLabels({
				owner: context.repo.owner,
				repo: context.repo.repo,
				issue_number: prNumber,
				labels: ["automated", "release"],
			});

			info(`âœ“ Created PR #${prNumber}: ${prUrl}`);
		} catch (error) {
			// Retry PR creation once after brief delay
			warning(`PR creation failed, retrying: ${error instanceof Error ? error.message : String(error)}`);
			await new Promise((resolve) => setTimeout(resolve, 2000));

			info(`Retrying PR creation via GraphQL...`);

			// Create PR via GraphQL (preserves branch-issue links)
			const prResult = (await github.graphql(
				`
				mutation ($repositoryId: ID!, $baseRefName: String!, $headRefName: String!, $title: String!, $body: String!) {
					createPullRequest(input: {
						repositoryId: $repositoryId
						baseRefName: $baseRefName
						headRefName: $headRefName
						title: $title
						body: $body
					}) {
						pullRequest {
							number
							url
							id
						}
					}
				}
				`,
				{
					repositoryId: repoNodeId,
					baseRefName: targetBranch,
					headRefName: releaseBranch,
					title: prTitle,
					body: prBody,
				},
			)) as { createPullRequest: { pullRequest: { number: number; url: string; id: string } } };

			prNumber = prResult.createPullRequest.pullRequest.number;
			prUrl = prResult.createPullRequest.pullRequest.url;
			info(`âœ“ PR created on retry: #${prNumber}`);

			await github.rest.issues.addLabels({
				owner: context.repo.owner,
				repo: context.repo.repo,
				issue_number: prNumber,
				labels: ["automated", "release"],
			});

			info(`âœ“ Created PR #${prNumber}: ${prUrl}`);
		}
	} else {
		info(`[DRY RUN] Would create PR with title: ${prTitle}`);
		info(`[DRY RUN] PR body:\n${prBody}`);
	}

	endGroup();

	// Build check details using summaryWriter (markdown, not HTML)
	const checkStatusTable = summaryWriter.keyValueTable([
		{ key: "Branch", value: `\`${releaseBranch}\`` },
		{ key: "Target", value: `\`${targetBranch}\`` },
		{ key: "PR", value: prNumber ? `[#${prNumber}](${prUrl})` : "_N/A (dry run)_" },
	]);

	const checkSections: Array<{ heading?: string; level?: 2 | 3; content: string }> = [
		{ heading: "Release Branch Created", content: checkStatusTable },
	];

	if (versionSummary) {
		checkSections.push({
			heading: "Version Changes",
			level: 3,
			content: summaryWriter.codeBlock(versionSummary, "text"),
		});
	}

	const checkDetails = summaryWriter.build(checkSections);

	const { data: checkRun } = await github.rest.checks.create({
		owner: context.repo.owner,
		repo: context.repo.repo,
		name: dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch",
		head_sha: context.sha,
		status: "completed",
		conclusion: "success",
		output: {
			title: prNumber ? `Created release PR #${prNumber}` : "Release branch created (dry run)",
			summary: checkDetails,
		},
	});

	// Write job summary using summaryWriter (markdown, not HTML)
	const jobCheckTitle = dryRun ? "ðŸ§ª Create Release Branch (Dry Run)" : "Create Release Branch";
	const jobStatusTable = summaryWriter.keyValueTable([
		{ key: "Branch", value: `\`${releaseBranch}\`` },
		{ key: "Target", value: `\`${targetBranch}\`` },
		{ key: "PR", value: prNumber ? `#${prNumber}` : "_N/A (dry run)_" },
	]);

	const jobSections: Array<{ heading?: string; level?: 2 | 3; content: string }> = [
		{
			heading: jobCheckTitle,
			content: prNumber ? `Created release PR #${prNumber}` : "Release branch created (dry run)",
		},
		{ heading: "Release Branch Created", level: 3, content: jobStatusTable },
	];

	if (versionSummary) {
		jobSections.push({
			heading: "Version Changes",
			level: 3,
			content: summaryWriter.codeBlock(versionSummary, "text"),
		});
	}

	const jobSummary = summaryWriter.build(jobSections);

	await summaryWriter.write(jobSummary);

	return {
		created: true,
		prNumber,
		checkId: checkRun.id,
		versionSummary,
	};
}
