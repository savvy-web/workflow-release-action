import * as fs from "node:fs";
import * as path from "node:path";
import * as core from "@actions/core";
import type { AuthSetupResult, ResolvedTarget } from "../types/publish-config.js";
import { registryToEnvName } from "./resolve-targets.js";

/**
 * Check if a registry uses OIDC-based authentication
 *
 * @remarks
 * OIDC (OpenID Connect) enables token-less publishing:
 * - npm public registry: Uses trusted publishing via Sigstore OIDC
 * - JSR: Uses OIDC natively in GitHub Actions
 *
 * @param registry - Registry URL to check
 * @returns true if registry uses OIDC
 */
function isOidcRegistry(registry: string | null): boolean {
	if (!registry) return false;
	// npm public registry supports OIDC trusted publishing
	if (registry.includes("registry.npmjs.org")) return true;
	return false;
}

/**
 * Validate that required tokens are available in environment
 *
 * @remarks
 * OIDC-based registries (npm, JSR) don't require tokens - they use
 * temporary credentials from the GitHub Actions OIDC provider.
 * Only GitHub Packages and custom registries require tokens.
 *
 * @param targets - Array of resolved targets to validate
 * @returns Validation result with missing tokens
 */
export function validateTokensAvailable(targets: ResolvedTarget[]): {
	valid: boolean;
	missing: Array<{ registry: string; tokenEnv: string }>;
} {
	const missing: Array<{ registry: string; tokenEnv: string }> = [];

	for (const target of targets) {
		// JSR uses OIDC in GitHub Actions, token is optional
		if (target.protocol === "jsr") {
			core.debug("JSR uses OIDC - no token required");
			continue;
		}

		// npm public registry uses OIDC trusted publishing
		if (isOidcRegistry(target.registry)) {
			core.debug("npm uses OIDC trusted publishing - no token required");
			continue;
		}

		// GitHub Packages and custom registries need tokens
		if (!target.tokenEnv) {
			missing.push({
				registry: target.registry || "unknown",
				tokenEnv: "tokenEnv not specified",
			});
			continue;
		}

		if (!process.env[target.tokenEnv]) {
			missing.push({
				registry: target.registry || "unknown",
				tokenEnv: target.tokenEnv,
			});
		}
	}

	return {
		valid: missing.length === 0,
		missing,
	};
}

/**
 * Generate .npmrc with authentication for non-OIDC registries
 *
 * @remarks
 * Only generates auth entries for:
 * - GitHub Packages (uses GitHub App token)
 * - Custom registries (uses provided tokens)
 *
 * OIDC registries (npm public, JSR) don't need .npmrc entries.
 *
 * @param targets - Array of resolved targets to configure auth for
 */
export function generateNpmrc(targets: ResolvedTarget[]): void {
	const lines: string[] = [];
	const processedRegistries = new Set<string>();

	for (const target of targets) {
		if (target.protocol !== "npm" || !target.registry) continue;
		if (processedRegistries.has(target.registry)) continue;

		// Skip OIDC registries - they don't need .npmrc auth
		if (isOidcRegistry(target.registry)) {
			core.info(`${target.registry} uses OIDC - skipping .npmrc auth`);
			processedRegistries.add(target.registry);
			continue;
		}

		processedRegistries.add(target.registry);

		if (!target.tokenEnv) {
			core.warning(`No token env var for registry: ${target.registry}`);
			continue;
		}

		const token = process.env[target.tokenEnv];
		if (!token) {
			core.warning(`Token env var ${target.tokenEnv} is not set for registry: ${target.registry}`);
			continue;
		}

		// Convert registry URL to npmrc format
		// https://npm.pkg.github.com/ -> //npm.pkg.github.com/:_authToken=TOKEN
		const registryPath = target.registry.replace(/^https?:/, "");

		lines.push(`${registryPath}:_authToken=${token}`);
		core.info(`Configured auth for: ${target.registry}`);
	}

	if (lines.length === 0) {
		core.debug("No registries to configure in .npmrc");
		return;
	}

	// Write to user's home .npmrc
	const npmrcPath = path.join(process.env.HOME || "~", ".npmrc");

	// Append to existing .npmrc if it exists
	const existingContent = fs.existsSync(npmrcPath) ? fs.readFileSync(npmrcPath, "utf-8") : "";

	const newContent = existingContent
		? `${existingContent}\n\n# Added by workflow-release-action\n${lines.join("\n")}\n`
		: `# Generated by workflow-release-action\n${lines.join("\n")}\n`;

	fs.writeFileSync(npmrcPath, newContent);
	core.info(`Updated .npmrc with ${lines.length} registry auth(s)`);
}

/**
 * Setup authentication for all registries
 *
 * @remarks
 * Authentication strategy:
 * - **npm public registry**: Uses OIDC trusted publishing (no token needed)
 * - **GitHub Packages**: Uses `github-token` input if provided, otherwise GitHub App token
 * - **JSR**: Uses OIDC (no token needed)
 * - **Custom registries**: Uses tokens from `custom-registries` input, or GitHub App token if not specified
 *
 * The GitHub token is set to GITHUB_TOKEN for GitHub Packages auth.
 * No .npmrc entry is needed for npm/JSR since they use OIDC.
 *
 * Custom registries format (one per line):
 * - `https://registry.example.com/` - Use GitHub App token
 * - `https://registry.example.com/=TOKEN` - Use explicit token (optional)
 *
 * @param targets - Array of resolved targets to setup auth for
 * @returns Authentication setup result
 */
export function setupRegistryAuth(targets: ResolvedTarget[]): AuthSetupResult {
	// Get tokens from state (set by pre.ts)
	const appToken = core.getState("token");
	const githubToken = core.getState("githubToken"); // Optional: workflow's GITHUB_TOKEN for packages:write

	// Determine which token to use for GitHub Packages
	// Prefer the explicit github-token input (has packages:write from workflow permissions)
	// Fall back to GitHub App token if not provided
	const packagesToken = githubToken || appToken;

	if (!packagesToken) {
		core.warning("No GitHub token available - GitHub Packages and custom registries may fail to authenticate");
	} else {
		// Set GITHUB_TOKEN for GitHub Packages
		process.env.GITHUB_TOKEN = packagesToken;
		if (githubToken) {
			core.info("Using workflow GITHUB_TOKEN for GitHub Packages authentication (packages:write)");
		} else {
			core.info("Using GitHub App token for GitHub Packages authentication");
		}
	}

	// Use appToken for custom registries (GitHub App token for API operations)
	const customRegistryToken = appToken;

	// Parse custom registries input
	// Format: "https://registry.example.com/" (uses GitHub App token) or "https://registry.example.com/=TOKEN"
	const customRegistriesInput = core.getInput("custom-registries");
	if (customRegistriesInput) {
		const inputLines = customRegistriesInput.split("\n").filter((line) => line.trim());
		for (const line of inputLines) {
			const equalIndex = line.indexOf("=");

			if (equalIndex === -1) {
				// No "=" found - registry URL only, use GitHub App token
				const registry = line.trim();
				if (registry && customRegistryToken) {
					const envVarName = registryToEnvName(registry);
					process.env[envVarName] = customRegistryToken;
					core.info(`Set ${envVarName} for custom registry: ${registry} (using GitHub App token)`);
				}
			} else {
				// Has "=" - could be explicit token or trailing "=" with no token
				const registry = line.slice(0, equalIndex).trim();
				const token = line.slice(equalIndex + 1).trim();

				if (registry) {
					const envVarName = registryToEnvName(registry);
					if (token) {
						// Explicit token provided
						process.env[envVarName] = token;
						core.info(`Set ${envVarName} for custom registry: ${registry}`);
					} else if (customRegistryToken) {
						// No token after "=" - use GitHub App token
						process.env[envVarName] = customRegistryToken;
						core.info(`Set ${envVarName} for custom registry: ${registry} (using GitHub App token)`);
					}
				}
			}
		}
	}

	// Validate tokens for non-OIDC registries
	const validation = validateTokensAvailable(targets);

	// Generate .npmrc for GitHub Packages and custom registries
	generateNpmrc(targets);

	return {
		success: validation.valid,
		configuredRegistries: Array.from(
			new Set(targets.filter((t) => t.protocol === "npm" && t.registry).map((t) => t.registry as string)),
		),
		missingTokens: validation.missing,
	};
}
