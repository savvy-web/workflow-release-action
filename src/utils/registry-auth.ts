import * as fs from "node:fs";
import * as path from "node:path";
import * as core from "@actions/core";
import type { AuthSetupResult, ResolvedTarget } from "../types/publish-config.js";
import { registryToEnvName } from "./resolve-targets.js";

/**
 * Validate that required tokens are available in environment
 *
 * @param targets - Array of resolved targets to validate
 * @returns Validation result with missing tokens
 */
export function validateTokensAvailable(targets: ResolvedTarget[]): {
	valid: boolean;
	missing: Array<{ registry: string; tokenEnv: string }>;
} {
	const missing: Array<{ registry: string; tokenEnv: string }> = [];

	for (const target of targets) {
		// JSR uses OIDC in GitHub Actions, token is optional
		if (target.protocol === "jsr") {
			if (target.tokenEnv && !process.env[target.tokenEnv]) {
				core.debug(`JSR token ${target.tokenEnv} not set, will use OIDC`);
			}
			continue;
		}

		if (!target.tokenEnv) {
			missing.push({
				registry: target.registry || "unknown",
				tokenEnv: "tokenEnv not specified",
			});
			continue;
		}

		if (!process.env[target.tokenEnv]) {
			missing.push({
				registry: target.registry || "unknown",
				tokenEnv: target.tokenEnv,
			});
		}
	}

	return {
		valid: missing.length === 0,
		missing,
	};
}

/**
 * Generate .npmrc with authentication for all npm-compatible registries
 *
 * @param targets - Array of resolved targets to configure auth for
 */
export function generateNpmrc(targets: ResolvedTarget[]): void {
	const lines: string[] = [];
	const processedRegistries = new Set<string>();

	for (const target of targets) {
		if (target.protocol !== "npm" || !target.registry) continue;
		if (processedRegistries.has(target.registry)) continue;

		processedRegistries.add(target.registry);

		if (!target.tokenEnv) {
			core.warning(`No token env var for registry: ${target.registry}`);
			continue;
		}

		const token = process.env[target.tokenEnv];
		if (!token) {
			core.warning(`Token env var ${target.tokenEnv} is not set for registry: ${target.registry}`);
			continue;
		}

		// Convert registry URL to npmrc format
		// https://registry.npmjs.org/ -> //registry.npmjs.org/:_authToken=TOKEN
		const registryPath = target.registry.replace(/^https?:/, "");

		lines.push(`${registryPath}:_authToken=${token}`);
		core.info(`Configured auth for: ${target.registry}`);
	}

	if (lines.length === 0) {
		core.debug("No registries to configure in .npmrc");
		return;
	}

	// Write to user's home .npmrc
	const npmrcPath = path.join(process.env.HOME || "~", ".npmrc");

	// Append to existing .npmrc if it exists
	const existingContent = fs.existsSync(npmrcPath) ? fs.readFileSync(npmrcPath, "utf-8") : "";

	const newContent = existingContent
		? `${existingContent}\n\n# Added by workflow-release-action\n${lines.join("\n")}\n`
		: `# Generated by workflow-release-action\n${lines.join("\n")}\n`;

	fs.writeFileSync(npmrcPath, newContent);
	core.info(`Updated .npmrc with ${lines.length} registry auth(s)`);
}

/**
 * Setup authentication for all registries
 * Called once at the start of the action
 *
 * @param targets - Array of resolved targets to setup auth for
 * @returns Authentication setup result
 */
export function setupRegistryAuth(targets: ResolvedTarget[]): AuthSetupResult {
	// Set GITHUB_TOKEN from input for GitHub Packages
	const githubToken = core.getInput("token", { required: true });
	process.env.GITHUB_TOKEN = githubToken;

	// Set NPM_TOKEN if provided
	const npmToken = core.getInput("npm-token");
	if (npmToken) {
		process.env.NPM_TOKEN = npmToken;
	}

	// Set JSR_TOKEN if provided
	const jsrToken = core.getInput("jsr-token");
	if (jsrToken) {
		process.env.JSR_TOKEN = jsrToken;
	}

	// Parse additional registry tokens from input
	const registryTokensInput = core.getInput("registry-tokens");
	if (registryTokensInput) {
		const inputLines = registryTokensInput.split("\n").filter((line) => line.trim());
		for (const line of inputLines) {
			const equalIndex = line.indexOf("=");
			if (equalIndex === -1) continue;

			const registry = line.slice(0, equalIndex).trim();
			const token = line.slice(equalIndex + 1).trim();

			if (registry && token) {
				const envVarName = registryToEnvName(registry);
				process.env[envVarName] = token;
				core.info(`Set ${envVarName} for ${registry}`);
			}
		}
	}

	// Validate all required tokens are present
	const validation = validateTokensAvailable(targets);

	// Generate .npmrc for npm-compatible registries
	generateNpmrc(targets);

	return {
		success: validation.valid,
		configuredRegistries: Array.from(
			new Set(targets.filter((t) => t.protocol === "npm" && t.registry).map((t) => t.registry as string)),
		),
		missingTokens: validation.missing,
	};
}
