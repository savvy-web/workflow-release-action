import * as fs from "node:fs";
import * as path from "node:path";
import * as core from "@actions/core";
import type { AuthSetupResult, ResolvedTarget } from "../types/publish-config.js";
import { registryToEnvName } from "./resolve-targets.js";

/**
 * Check if a registry uses OIDC-based authentication
 *
 * @remarks
 * OIDC (OpenID Connect) enables token-less publishing:
 * - npm public registry: Uses trusted publishing via Sigstore OIDC
 * - JSR: Uses OIDC natively in GitHub Actions
 *
 * @param registry - Registry URL to check
 * @returns true if registry uses OIDC
 */
function isOidcRegistry(registry: string | null): boolean {
	if (!registry) return false;
	// npm public registry supports OIDC trusted publishing
	if (registry.includes("registry.npmjs.org")) return true;
	return false;
}

/**
 * Validate that required tokens are available in environment
 *
 * @remarks
 * OIDC-based registries (npm, JSR) don't require tokens - they use
 * temporary credentials from the GitHub Actions OIDC provider.
 * Only GitHub Packages and custom registries require tokens.
 *
 * @param targets - Array of resolved targets to validate
 * @returns Validation result with missing tokens
 */
export function validateTokensAvailable(targets: ResolvedTarget[]): {
	valid: boolean;
	missing: Array<{ registry: string; tokenEnv: string }>;
} {
	const missing: Array<{ registry: string; tokenEnv: string }> = [];

	for (const target of targets) {
		// JSR uses OIDC in GitHub Actions, token is optional
		if (target.protocol === "jsr") {
			core.debug("JSR uses OIDC - no token required");
			continue;
		}

		// npm public registry uses OIDC trusted publishing
		if (isOidcRegistry(target.registry)) {
			core.debug("npm uses OIDC trusted publishing - no token required");
			continue;
		}

		// GitHub Packages and custom registries need tokens
		if (!target.tokenEnv) {
			missing.push({
				registry: target.registry || "unknown",
				tokenEnv: "tokenEnv not specified",
			});
			continue;
		}

		if (!process.env[target.tokenEnv]) {
			missing.push({
				registry: target.registry || "unknown",
				tokenEnv: target.tokenEnv,
			});
		}
	}

	return {
		valid: missing.length === 0,
		missing,
	};
}

/**
 * Generate .npmrc with authentication for non-OIDC registries
 *
 * @remarks
 * Only generates auth entries for:
 * - GitHub Packages (uses GitHub App token)
 * - Custom registries (uses provided tokens)
 *
 * OIDC registries (npm public, JSR) don't need .npmrc entries.
 *
 * @param targets - Array of resolved targets to configure auth for
 */
export function generateNpmrc(targets: ResolvedTarget[]): void {
	const lines: string[] = [];
	const processedRegistries = new Set<string>();

	for (const target of targets) {
		if (target.protocol !== "npm" || !target.registry) continue;
		if (processedRegistries.has(target.registry)) continue;

		// Skip OIDC registries - they don't need .npmrc auth
		if (isOidcRegistry(target.registry)) {
			core.info(`${target.registry} uses OIDC - skipping .npmrc auth`);
			processedRegistries.add(target.registry);
			continue;
		}

		processedRegistries.add(target.registry);

		if (!target.tokenEnv) {
			core.warning(`No token env var for registry: ${target.registry}`);
			continue;
		}

		const token = process.env[target.tokenEnv];
		if (!token) {
			core.warning(`Token env var ${target.tokenEnv} is not set for registry: ${target.registry}`);
			continue;
		}

		// Convert registry URL to npmrc format
		// https://npm.pkg.github.com/ -> //npm.pkg.github.com/:_authToken=TOKEN
		const registryPath = target.registry.replace(/^https?:/, "");

		lines.push(`${registryPath}:_authToken=${token}`);
		core.info(`Configured auth for: ${target.registry}`);
	}

	if (lines.length === 0) {
		core.debug("No registries to configure in .npmrc");
		return;
	}

	// Write to user's home .npmrc
	const npmrcPath = path.join(process.env.HOME || "~", ".npmrc");

	// Append to existing .npmrc if it exists
	const existingContent = fs.existsSync(npmrcPath) ? fs.readFileSync(npmrcPath, "utf-8") : "";

	const newContent = existingContent
		? `${existingContent}\n\n# Added by workflow-release-action\n${lines.join("\n")}\n`
		: `# Generated by workflow-release-action\n${lines.join("\n")}\n`;

	fs.writeFileSync(npmrcPath, newContent);
	core.info(`Updated .npmrc with ${lines.length} registry auth(s)`);
}

/**
 * Setup authentication for all registries
 *
 * @remarks
 * Authentication strategy:
 * - **npm public registry**: Uses OIDC trusted publishing (no token needed)
 * - **GitHub Packages**: Uses GitHub App token (passed as `token` input)
 * - **JSR**: Uses OIDC (no token needed)
 * - **Custom registries**: Uses tokens from `registry-tokens` input
 *
 * The GitHub App token is set to GITHUB_TOKEN for GitHub Packages auth.
 * No .npmrc entry is needed for npm/JSR since they use OIDC.
 *
 * @param targets - Array of resolved targets to setup auth for
 * @returns Authentication setup result
 */
export function setupRegistryAuth(targets: ResolvedTarget[]): AuthSetupResult {
	// Set GITHUB_TOKEN from input for GitHub Packages
	// This is the GitHub App token, not the default GITHUB_TOKEN
	const githubToken = core.getInput("token", { required: true });
	process.env.GITHUB_TOKEN = githubToken;
	core.info("Using GitHub App token for GitHub Packages authentication");

	// Parse additional registry tokens for custom registries
	const registryTokensInput = core.getInput("registry-tokens");
	if (registryTokensInput) {
		const inputLines = registryTokensInput.split("\n").filter((line) => line.trim());
		for (const line of inputLines) {
			const equalIndex = line.indexOf("=");
			if (equalIndex === -1) continue;

			const registry = line.slice(0, equalIndex).trim();
			const token = line.slice(equalIndex + 1).trim();

			if (registry && token) {
				const envVarName = registryToEnvName(registry);
				process.env[envVarName] = token;
				core.info(`Set ${envVarName} for custom registry: ${registry}`);
			}
		}
	}

	// Validate tokens for non-OIDC registries
	const validation = validateTokensAvailable(targets);

	// Generate .npmrc for GitHub Packages and custom registries
	generateNpmrc(targets);

	return {
		success: validation.valid,
		configuredRegistries: Array.from(
			new Set(targets.filter((t) => t.protocol === "npm" && t.registry).map((t) => t.registry as string)),
		),
		missingTokens: validation.missing,
	};
}
